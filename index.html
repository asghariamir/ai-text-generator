<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>How AI Makes Text | Mathswell</title>
    <link rel="icon" href="/logo-mathswell-square-mirror.ico" type="image/x-icon">
    <link rel="icon" href="/logo-mathswell-square-mirror.svg" type="image/svg+xml">
    
    <style>
        /* Root variables - Mathswell standard colors */
        :root {
            --primary: #0f766e;
            --primary-light: #10b981;
            --background: #f7faf9;
            --interactive: #e6fffb;
            --text-primary: #212121;
            --text-muted: #4b5563;
            --accent-amber: #f59e0b;
            --accent-red: #ef4444;
            --success: #10b981;
            --rare: #8b5cf6;
        }
        
        /* Base styles */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: var(--background);
            color: var(--text-primary);
            padding-top: 60px;
            overflow-x: hidden;
        }
        
        /* CENTERED Navigation - Mathswell standard */
        .mathswell-nav {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background: white;
            border-bottom: 2px solid var(--primary);
            padding: 0.75rem 1rem;
            z-index: 1000;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        .mw-link {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            text-decoration: none;
            color: var(--primary);
            font-weight: 600;
            letter-spacing: 1px;
        }
        
        /* Container */
        .container {
            max-width: 1000px;
            margin: 2rem auto;
            padding: 0 1rem;
        }
        
        /* CENTERED Tabs - Mathswell standard */
        .tabs {
            display: flex;
            gap: 0.5rem;
            justify-content: center;
            background: white;
            padding: 0.5rem;
            border-radius: 12px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.05);
            margin-bottom: 2rem;
        }
        
        .tab-btn {
            padding: 0.75rem 1.5rem;
            border: none;
            background: transparent;
            color: var(--text-muted);
            cursor: pointer;
            border-radius: 8px;
            font-weight: 500;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .tab-btn.active {
            background: var(--primary);
            color: white;
        }
        
        .tab-btn:hover:not(.active) {
            background: var(--interactive);
            color: var(--primary);
        }
        
        /* Tab content */
        .tab-content {
            display: none;
            animation: fadeIn 0.3s ease;
        }
        
        .tab-content.active {
            display: block;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        /* Info box */
        .info-box {
            background: var(--interactive);
            border-left: 4px solid var(--primary);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
        }
        
        .info-box p {
            margin: 0;
            color: var(--primary);
            font-size: 0.95rem;
            line-height: 1.5;
        }
        
        /* Hero card */
        .hero-card {
            background: white;
            border-radius: 12px;
            padding: 2rem;
            box-shadow: 0 4px 16px rgba(0,0,0,0.1);
            margin-bottom: 2rem;
            text-align: center;
        }
        
        .hero-card h1 {
            color: var(--primary);
            margin-bottom: 0.5rem;
            font-size: 2rem;
        }
        
        .hero-card p {
            font-size: 1.1rem;
            color: var(--text-muted);
            max-width: 600px;
            margin: 0 auto;
        }
        
        .hero-card .note {
            font-size: 0.9rem;
            color: var(--text-muted);
            margin-top: 1rem;
            font-style: italic;
        }
        
        /* Context meter */
        .context-meter {
            background: white;
            border-radius: 8px;
            padding: 1rem;
            margin: 1rem 0;
            box-shadow: 0 2px 8px rgba(0,0,0,0.05);
        }
        
        .context-label {
            font-size: 0.85rem;
            color: var(--text-muted);
            margin-bottom: 0.5rem;
            text-align: center;
        }
        
        .context-bar {
            height: 12px;
            background: #e5e5e5;
            border-radius: 6px;
            overflow: hidden;
        }
        
        .context-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--primary-light), var(--primary));
            transition: width 0.5s ease;
            width: 0%;
        }
        
        /* Big button */
        .big-btn {
            background: linear-gradient(135deg, var(--primary), var(--primary-light));
            color: white;
            border: none;
            padding: 1.25rem 2.5rem;
            font-size: 1.3rem;
            font-weight: 600;
            border-radius: 12px;
            cursor: pointer;
            box-shadow: 0 6px 20px rgba(15, 118, 110, 0.3);
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 0.75rem;
            margin: 2rem auto;
        }
        
        .big-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 24px rgba(15, 118, 110, 0.4);
        }
        
        .big-btn:active {
            transform: translateY(0);
        }
        
        /* Spinner container */
        .spinner-stage {
            background: white;
            border-radius: 12px;
            padding: 2rem;
            box-shadow: 0 4px 16px rgba(0,0,0,0.1);
            margin-bottom: 2rem;
            display: none;
        }
        
        .spinner-stage.active {
            display: block;
        }
        
        .stage-title {
            text-align: center;
            color: var(--primary);
            font-size: 1.5rem;
            margin-bottom: 1rem;
            font-weight: 600;
        }
        
        /* Spinner wheel */
        .spinner-container {
            position: relative;
            width: 280px;
            height: 280px;
            margin: 2rem auto;
        }
        
        .spinner-wheel {
            width: 100%;
            height: 100%;
            border-radius: 50%;
            position: relative;
            overflow: hidden;
            box-shadow: 0 8px 32px rgba(0,0,0,0.15);
            transition: transform 3s cubic-bezier(0.17, 0.67, 0.83, 0.67);
        }
        
        .spinner-wheel.fast {
            transition: transform 0.6s cubic-bezier(0.17, 0.67, 0.83, 0.67);
        }
        
        @media (prefers-reduced-motion: reduce) {
            .spinner-wheel {
                animation: none !important;
                transition: none !important;
            }
        }
        
        .spinner-label {
            position: absolute;
            color: white;
            font-weight: 600;
            font-size: 1.5rem;
            text-shadow: 0 2px 4px rgba(0,0,0,0.3);
            pointer-events: none;
        }
        
        .spinner-pointer {
            position: absolute;
            top: -20px;
            left: 50%;
            transform: translateX(-50%);
            width: 0;
            height: 0;
            border-left: 15px solid transparent;
            border-right: 15px solid transparent;
            border-top: 30px solid var(--accent-red);
            z-index: 10;
            filter: drop-shadow(0 2px 4px rgba(0,0,0,0.2));
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(1800deg); }
        }
        
        @keyframes spin-fast {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(720deg); }
        }
        
        .spinning {
            animation: spin 3s cubic-bezier(0.17, 0.67, 0.83, 0.67);
        }
        
        .spinning.fast {
            animation: spin-fast 0.8s cubic-bezier(0.17, 0.67, 0.83, 0.67);
        }
        
        /* Comic strip */
        .comic-strip {
            display: flex;
            gap: 1rem;
            justify-content: center;
            margin: 2rem 0;
            flex-wrap: wrap;
        }
        
        .comic-bubble {
            background: white;
            border: 3px solid var(--primary);
            border-radius: 20px;
            padding: 1rem 1.5rem;
            position: relative;
            min-width: 120px;
            text-align: center;
            font-size: 1.5rem;
            font-weight: 600;
            opacity: 0;
            transform: scale(0.8) translateY(20px);
            animation: popIn 0.5s ease forwards;
        }
        
        @keyframes popIn {
            to {
                opacity: 1;
                transform: scale(1) translateY(0);
            }
        }
        
        .comic-bubble:nth-child(2) { animation-delay: 0.2s; }
        .comic-bubble:nth-child(3) { animation-delay: 0.4s; }
        
        .comic-bubble::after {
            content: '';
            position: absolute;
            bottom: -10px;
            left: 50%;
            transform: translateX(-50%);
            width: 0;
            height: 0;
            border-left: 10px solid transparent;
            border-right: 10px solid transparent;
            border-top: 10px solid var(--primary);
        }
        
        /* Controls panel */
        .controls-panel {
            background: var(--interactive);
            border-radius: 12px;
            padding: 1.5rem;
            margin: 2rem 0;
        }
        
        .control-group {
            margin-bottom: 2rem;
        }
        
        .control-group:last-child {
            margin-bottom: 0;
        }
        
        .control-label {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-weight: 600;
            color: var(--primary);
            margin-bottom: 0.5rem;
            font-size: 1.1rem;
        }
        
        .control-description {
            font-size: 0.85rem;
            color: var(--text-muted);
            margin-bottom: 0.75rem;
            line-height: 1.4;
        }
        
        .control-range {
            display: flex;
            align-items: center;
            gap: 1rem;
        }
        
        .control-slider {
            flex: 1;
            -webkit-appearance: none;
            appearance: none;
            height: 12px;
            background: white;
            border-radius: 6px;
            outline: none;
        }
        
        .control-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 28px;
            height: 28px;
            background: var(--primary);
            cursor: pointer;
            border-radius: 50%;
            border: 3px solid white;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }
        
        .control-slider::-moz-range-thumb {
            width: 28px;
            height: 28px;
            background: var(--primary);
            cursor: pointer;
            border-radius: 50%;
            border: 3px solid white;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }
        
        /* Speed toggle */
        .speed-toggle {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin: 1rem 0;
            justify-content: center;
        }
        
        .speed-checkbox {
            width: 20px;
            height: 20px;
            accent-color: var(--primary);
        }
        
        /* Pattern gallery */
        .pattern-gallery {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
            gap: 0.75rem;
            padding: 1.5rem;
            background: var(--interactive);
            border-radius: 12px;
            min-height: 300px;
        }
        
        .pattern-chip {
            aspect-ratio: 1;
            background: white;
            border: 2px solid var(--primary);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
            position: relative;
            transition: all 0.3s ease;
            cursor: pointer;
        }
        
        .pattern-chip:hover {
            transform: scale(1.1);
            z-index: 10;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }
        
        .pattern-chip.common {
            grid-column: span 2;
            grid-row: span 2;
            font-size: 1.8rem;
            border-width: 3px;
            background: linear-gradient(135deg, white, var(--interactive));
        }
        
        .pattern-chip.rare {
            opacity: 0.7;
            border-style: dashed;
        }
        
        .pattern-count {
            position: absolute;
            bottom: 4px;
            right: 4px;
            font-size: 0.7rem;
            color: var(--text-muted);
            background: white;
            padding: 2px 6px;
            border-radius: 4px;
        }
        
        .pattern-legend {
            text-align: center;
            color: var(--text-muted);
            font-size: 0.9rem;
            margin-bottom: 1rem;
            font-style: italic;
        }
        
        /* Target card */
        .target-card {
            background: linear-gradient(135deg, white, var(--interactive));
            border: 3px solid var(--primary);
            border-radius: 12px;
            padding: 2rem;
            text-align: center;
            margin-bottom: 2rem;
        }
        
        .target-sequence {
            display: flex;
            gap: 1rem;
            justify-content: center;
            margin: 1.5rem 0;
        }
        
        .target-piece {
            width: 90px;
            height: 90px;
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2.5rem;
            background: white;
            border: 2px solid var(--primary);
        }
        
        .target-arrow {
            font-size: 1.5rem;
            color: var(--primary);
            display: flex;
            align-items: center;
        }
        
        /* Live generation display */
        .live-generation {
            background: white;
            border-radius: 12px;
            padding: 1.5rem;
            margin: 2rem 0;
            box-shadow: 0 4px 16px rgba(0,0,0,0.1);
        }
        
        .live-title {
            font-weight: 600;
            color: var(--primary);
            margin-bottom: 1rem;
            text-align: center;
            font-size: 1.1rem;
        }
        
        .live-patterns {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            justify-content: center;
            min-height: 60px;
        }
        
        .live-pattern {
            background: var(--interactive);
            border: 2px solid var(--primary);
            border-radius: 8px;
            padding: 0.5rem 1rem;
            font-size: 1.2rem;
            animation: slideIn 0.3s ease;
        }
        
        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateX(-20px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }
        
        /* Success meter */
        .success-meter {
            background: white;
            border-radius: 8px;
            padding: 1rem;
            margin-top: 1rem;
            text-align: center;
        }
        
        .success-percentage {
            font-size: 2.5rem;
            font-weight: 700;
            color: var(--primary);
        }
        
        .success-label {
            color: var(--text-muted);
            font-size: 0.95rem;
            margin-top: 0.25rem;
        }
        
        /* MathPal robot */
        .mathpal-container {
            text-align: center;
            margin: 2rem 0;
        }
        
        .mathpal-svg {
            width: 80px;
            height: 80px;
            margin: 0 auto 1rem;
        }
        
        .mathpal-tip {
            background: var(--interactive);
            border: 2px solid var(--primary);
            border-radius: 12px;
            padding: 1rem;
            position: relative;
            max-width: 500px;
            margin: 0 auto;
        }
        
        .mathpal-tip::before {
            content: '';
            position: absolute;
            top: -8px;
            left: 50%;
            transform: translateX(-50%);
            width: 0;
            height: 0;
            border-left: 8px solid transparent;
            border-right: 8px solid transparent;
            border-bottom: 8px solid var(--primary);
        }
        
        /* Number input */
        .number-input {
            display: flex;
            align-items: center;
            gap: 1rem;
            justify-content: center;
            margin: 1rem 0;
        }
        
        .number-input input {
            width: 80px;
            padding: 0.5rem;
            font-size: 1.1rem;
            border: 2px solid var(--primary);
            border-radius: 6px;
            text-align: center;
        }
        
        .number-input label {
            font-weight: 500;
            color: var(--text-primary);
        }
        
        /* Network tab styles */
        .network-container {
            background: white;
            border-radius: 12px;
            padding: 2rem;
            box-shadow: 0 4px 16px rgba(0,0,0,0.1);
            margin-bottom: 2rem;
        }
        
        .wheels-row {
            display: flex;
            justify-content: space-around;
            align-items: center;
            margin: 2rem 0;
            position: relative;
            min-height: 350px;
        }
        
        .wheel-column {
            display: flex;
            flex-direction: column;
            align-items: center;
            position: relative;
        }
        
        .wheel-label {
            font-weight: 600;
            color: var(--primary);
            margin-bottom: 0.5rem;
            font-size: 1.1rem;
        }
        
        .mini-wheel {
            width: 150px;
            height: 150px;
            border-radius: 50%;
            position: relative;
            box-shadow: 0 4px 16px rgba(0,0,0,0.1);
            transition: all 0.3s ease;
        }
        
        .connection-line {
            position: absolute;
            height: 3px;
            background: linear-gradient(90deg, var(--primary-light), var(--primary));
            transform-origin: left center;
            z-index: 1;
            opacity: 0.3;
            transition: all 0.3s ease;
        }
        
        .connection-line.active {
            opacity: 1;
            height: 5px;
            box-shadow: 0 0 10px var(--primary-light);
        }
        
        .connection-line.backward {
            background: linear-gradient(90deg, var(--rare), var(--accent-amber));
        }
        
        .network-output {
            background: var(--interactive);
            border-radius: 8px;
            padding: 1.5rem;
            margin-top: 2rem;
            text-align: center;
        }
        
        .network-output-text {
            font-size: 1.5rem;
            font-weight: 600;
            color: var(--primary);
            margin-bottom: 0.5rem;
        }
        
        .network-controls {
            display: flex;
            gap: 1rem;
            justify-content: center;
            margin: 2rem 0;
        }
        
        .network-btn {
            background: var(--primary);
            color: white;
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.2s ease;
        }
        
        .network-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(15, 118, 110, 0.3);
        }
        
        .mode-selector {
            display: flex;
            gap: 1rem;
            justify-content: center;
            margin: 1rem 0;
        }
        
        .mode-btn {
            padding: 0.5rem 1rem;
            border: 2px solid var(--primary);
            background: white;
            color: var(--primary);
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .mode-btn.active {
            background: var(--primary);
            color: white;
        }
        
        /* Sparkle effect */
        @keyframes sparkle {
            0%, 100% { 
                opacity: 0; 
                transform: scale(0) rotate(0deg); 
            }
            50% { 
                opacity: 1; 
                transform: scale(1) rotate(180deg); 
            }
        }
        
        .sparkle {
            position: fixed;
            pointer-events: none;
            animation: sparkle 1s ease;
            z-index: 1000;
            font-size: 30px;
        }
        
        /* Confetti */
        @keyframes confetti-fall {
            0% { 
                transform: translateY(-100vh) rotate(0deg); 
                opacity: 1; 
            }
            100% { 
                transform: translateY(100vh) rotate(720deg); 
                opacity: 0; 
            }
        }
        
        .confetti {
            position: fixed;
            width: 10px;
            height: 10px;
            top: -10px;
            pointer-events: none;
            animation: confetti-fall 3s linear;
            z-index: 1000;
        }
        
        /* Mobile responsive */
        @media (max-width: 768px) {
            .hero-card h1 {
                font-size: 1.5rem;
            }
            
            .big-btn {
                padding: 1rem 2rem;
                font-size: 1.1rem;
            }
            
            .spinner-container {
                width: 240px;
                height: 240px;
            }
            
            .comic-strip {
                flex-direction: column;
                align-items: center;
            }
            
            .target-sequence {
                transform: scale(0.85);
            }
            
            .pattern-gallery {
                grid-template-columns: repeat(auto-fill, minmax(60px, 1fr));
            }
            
            .wheels-row {
                flex-direction: column;
                gap: 2rem;
                min-height: auto;
            }
            
            .mini-wheel {
                width: 120px;
                height: 120px;
            }
            
            .tabs {
                flex-wrap: wrap;
            }
            
            .tab-btn {
                padding: 0.5rem 1rem;
                font-size: 0.9rem;
            }
        }
    </style>
</head>
<body>
    <!-- Centered Mathswell Navigation -->
    <div class="mathswell-nav">
        <a href="/" class="mw-link">
            <img src="/logo-mathswell-square-mirror.svg" alt="Mathswell" width="28" height="28">
            <span>MATHSWELL</span>
        </a>
    </div>
    
    <div class="container">
        <!-- Centered Tab Navigation -->
        <div class="tabs">
            <button class="tab-btn active" data-tab="play">
                <span>üé¨</span> Play
            </button>
            <button class="tab-btn" data-tab="patterns">
                <span>üé®</span> Patterns
            </button>
            <button class="tab-btn" data-tab="challenge">
                <span>üéØ</span> Rig the Wheel
            </button>
            <button class="tab-btn" data-tab="network">
                <span>üß†</span> Network
            </button>
        </div>
        
        <!-- Tab 1: Play -->
        <div id="play" class="tab-content active">
            <div class="hero-card">
                <h1>How AI Makes Sentences ‚ú®</h1>
                <p>AI picks the next piece of text like a magic spinner wheel whose slices change with context.</p>
                <p class="note">Before writing, the AI has already studied lots of text. That study sets the weights on the wheel. Your sliders only change how it picks, not what it knows.</p>
            </div>
            
            <div class="info-box">
                <p>
                    <strong>üéØ Try this:</strong> Press "Make a Sentence" to watch how AI builds text piece by piece. 
                    Notice how the wheel changes after each choice - that's because what comes next depends on what came before!
                </p>
            </div>
            
            <div class="speed-toggle">
                <input type="checkbox" id="quickMode" class="speed-checkbox">
                <label for="quickMode">‚ö° Quick mode (faster spinning)</label>
            </div>
            
            <button class="big-btn" onclick="startSpinning()">
                <span>üé¨</span> Make a Sentence
            </button>
            
            <!-- Context meter -->
            <div class="context-meter">
                <div class="context-label">Each new piece reshapes the wheel by reminding the AI what we've already said</div>
                <div class="context-bar">
                    <div class="context-fill" id="contextFill"></div>
                </div>
            </div>
            
            <!-- Spinner stage -->
            <div class="spinner-stage" id="spinnerStage">
                <h2 class="stage-title" id="stageTitle">Choosing the Start...</h2>
                
                <div class="spinner-container">
                    <div class="spinner-pointer"></div>
                    <div class="spinner-wheel" id="spinnerWheel"></div>
                </div>
                
                <div class="comic-strip" id="comicStrip" aria-live="polite"></div>
            </div>
            
            <!-- Simple controls -->
            <div class="controls-panel">
                <div class="control-group">
                    <div class="control-label">
                        <span>‚ùÑÔ∏è</span>
                        <span>Creativity</span>
                        <span>üî•</span>
                    </div>
                    <div class="control-description">
                        Low = picks the obvious slice. High = gives smaller slices a chance.
                    </div>
                    <div class="control-range">
                        <span>Boring</span>
                        <input type="range" class="control-slider" id="creativity" 
                               min="0.1" max="2.0" step="0.1" value="1.0">
                        <span>Wild</span>
                    </div>
                </div>
                
                <div class="control-group">
                    <div class="control-label">
                        <span>üìù</span>
                        <span>Stick to Favorites</span>
                    </div>
                    <div class="control-description">
                        Keep only the top slices whose sizes together reach this amount. Off keeps every slice.
                    </div>
                    <div class="control-range">
                        <span>Off</span>
                        <input type="range" class="control-slider" id="favorites" 
                               min="0.3" max="1.0" step="0.05" value="1.0">
                        <span>Strong</span>
                    </div>
                </div>
                
                <div class="control-group">
                    <div class="control-label">
                        <span>üîÑ</span>
                        <span>Avoid Repeats</span>
                    </div>
                    <div class="control-description">
                        If the same piece popped up already, gently shrink its slice.
                    </div>
                    <div class="control-range">
                        <span>Off</span>
                        <input type="range" class="control-slider" id="avoidRepeats" 
                               min="0" max="0.5" step="0.05" value="0">
                        <span>Strong</span>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Tab 2: Patterns -->
        <div id="patterns" class="tab-content">
            <div class="hero-card">
                <h2 style="color: var(--primary);">Pattern Gallery üé®</h2>
                <p>This shows why AI writing has a style: when they write, they favor some patterns more than others.</p>
            </div>
            
            <div class="info-box">
                <p>
                    <strong>üî¨ What you'll see:</strong> When AI generates lots of sentences, some patterns appear often (the big ones) while others are rare. 
                    Lower creativity ‚Üí more big duplicates. Higher ‚Üí more small unique tiles.
                </p>
            </div>
            
            <div class="speed-toggle">
                <input type="checkbox" id="samePatterns" class="speed-checkbox">
                <label for="samePatterns">üîÅ Generate same patterns each time (for comparing settings)</label>
            </div>
            
            <div class="number-input">
                <label>Generate</label>
                <input type="number" id="patternCount" min="10" max="100" value="30">
                <label>patterns</label>
            </div>
            
            <button class="big-btn" onclick="generateMany()">
                <span>üé≤</span> Generate Patterns
            </button>
            
            <!-- Show spinner wheel here too -->
            <div class="spinner-stage" id="patternSpinner" style="display: none;">
                <h2 class="stage-title">Generating...</h2>
                <div class="spinner-container">
                    <div class="spinner-pointer"></div>
                    <div class="spinner-wheel" id="patternWheel"></div>
                </div>
            </div>
            
            <div class="pattern-legend" id="patternLegend"></div>
            
            <div class="pattern-gallery" id="patternGallery">
                <!-- Pattern chips appear here -->
            </div>
        </div>
        
        <!-- Tab 3: Challenge -->
        <div id="challenge" class="tab-content">
            <div class="target-card">
                <h2 style="color: var(--primary); margin-bottom: 1rem;">
                    Try to Make This Pattern! üéØ
                </h2>
                
                <div class="target-sequence" id="targetSequence">
                    <div class="target-piece">üê∂</div>
                    <div class="target-arrow">‚Üí</div>
                    <div class="target-piece">üò¥</div>
                    <div class="target-arrow">‚Üí</div>
                    <div class="target-piece">ü™ü</div>
                </div>
                
                <button onclick="generateNewChallenge()" style="background: var(--primary); color: white; border: none; padding: 0.5rem 1rem; border-radius: 6px; cursor: pointer; margin-top: 1rem;">
                    üé≤ New Challenge
                </button>
            </div>
            
            <!-- Live generation display with integrated test button -->
            <div class="live-generation">
                <div class="live-title">What your settings are making right now:</div>
                <div class="live-patterns" id="livePatterns" aria-live="polite">
                    <!-- Live patterns appear here -->
                </div>
                
                <div style="margin-top: 1rem;">
                    <div class="success-meter" style="margin: 0;">
                        <div class="success-percentage" id="successRate">7%</div>
                        <div class="success-label">Chance of hitting target: <span id="successChance">7%</span></div>
                    </div>
                    <p style="text-align: center; color: var(--text-muted); font-size: 0.85rem; margin-top: 0.5rem; font-style: italic;">
                        This percentage is calculated from testing 100 random generations with your current settings - it updates instantly as you move the sliders!
                    </p>
                </div>
            </div>
            
            <!-- Controls -->
            <div class="controls-panel">
                <div class="control-group">
                    <div class="control-label">
                        <span>üé®</span>
                        <span>Starting Bias</span>
                    </div>
                    <div class="control-range">
                        <span>üê∂ Dogs</span>
                        <input type="range" class="control-slider" id="startBias" 
                               min="0" max="100" value="50" oninput="updateLiveGeneration()">
                        <span>Cats üê±</span>
                    </div>
                </div>
                
                <div class="control-group">
                    <div class="control-label">
                        <span>‚ùÑÔ∏è</span>
                        <span>Creativity</span>
                        <span>üî•</span>
                    </div>
                    <div class="control-range">
                        <span>Low</span>
                        <input type="range" class="control-slider" id="challengeCreativity" 
                               min="0.1" max="2.0" step="0.1" value="0.5" oninput="updateLiveGeneration()">
                        <span>High</span>
                    </div>
                </div>
                
                <div class="control-group">
                    <div class="control-label">
                        <span>üìù</span>
                        <span>Stick to Favorites</span>
                    </div>
                    <div class="control-range">
                        <span>Off</span>
                        <input type="range" class="control-slider" id="challengeFavorites" 
                               min="0.3" max="1.0" step="0.05" value="1.0" oninput="updateLiveGeneration()">
                        <span>Strong</span>
                    </div>
                </div>
            </div>
            
            <!-- MathPal helper -->
            <div class="mathpal-container">
                <svg class="mathpal-svg" viewBox="0 0 100 100">
                    <circle cx="50" cy="50" r="45" fill="#e6fffb"/>
                    <rect x="35" y="60" width="30" height="25" fill="#0f766e" rx="3"/>
                    <rect x="30" y="35" width="40" height="30" fill="#10b981" rx="8"/>
                    <line x1="50" y1="35" x2="50" y2="25" stroke="#0f766e" stroke-width="2"/>
                    <circle cx="50" cy="23" r="3" fill="#f59e0b"/>
                    <circle cx="40" cy="47" r="5" fill="white"/>
                    <circle cx="60" cy="47" r="5" fill="white"/>
                    <circle cx="40" cy="47" r="3" fill="#0f766e"/>
                    <circle cx="60" cy="47" r="3" fill="#0f766e"/>
                    <path d="M 40 55 Q 50 60 60 55" stroke="#0f766e" stroke-width="2" fill="none"/>
                </svg>
                
                <div class="mathpal-tip">
                    <p id="tipText" style="color: var(--primary); font-weight: 500; margin: 0;">
                        üí° Hey! I'd try sliding that bias towards cats and turning creativity way down. That should help!
                    </p>
                </div>
            </div>
            
            <div class="info-box">
                <p>
                    <strong>üéÆ Challenge:</strong> Can you adjust the controls to make the target pattern more likely?
                </p>
                <p style="margin-top: 0.5rem;">
                    <strong>How this relates to using ChatGPT/Claude:</strong><br>
                    ‚Ä¢ "Starting Bias" = Your prompt (e.g., "Write about cats" biases toward cat content)<br>
                    ‚Ä¢ "Creativity" = Instructions like "be creative" vs "be precise and factual"<br>
                    ‚Ä¢ "Stick to Favorites" = Asking for "common examples" vs "think outside the box"<br>
                    <em>Some AI tools expose these as actual settings, but mostly you control them through how you write your prompts!</em>
                </p>
            </div>
        </div>
        
        <!-- Tab 4: Network -->
        <div id="network" class="tab-content">
            <div class="hero-card">
                <h2 style="color: var(--primary);">How AI Layers Process Text üß†</h2>
                <p>See how neural networks transform your input through multiple processing layers - try both simulation and real AI modes!</p>
            </div>
            
            <!-- AI Mode Toggle -->
            <div style="background: var(--interactive); border: 2px solid var(--primary); border-radius: 12px; padding: 1rem; margin-bottom: 2rem;">
                <div style="display: flex; align-items: center; justify-content: center; gap: 2rem;">
                    <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer;">
                        <input type="radio" name="aiMode" value="simulation" checked onclick="setAIMode('simulation')" style="width: 20px; height: 20px;">
                        <span style="font-weight: 500;">üéÆ Simulation Mode</span>
                    </label>
                    <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer;">
                        <input type="radio" name="aiMode" value="real" onclick="setAIMode('real')" style="width: 20px; height: 20px;">
                        <span style="font-weight: 500;">ü§ñ Real AI Mode (Gemini)</span>
                    </label>
                </div>
                <p id="modeDescription" style="text-align: center; color: var(--text-muted); font-size: 0.85rem; margin: 0.5rem 0 0 0;">
                    Currently using simplified simulation to demonstrate the concept
                </p>
            </div>
            
            <!-- AI Disclosure for Real Mode -->
            <div id="aiDisclosure" style="display: none; background: #fff3cd; border: 2px solid #ffc107; border-radius: 8px; padding: 1rem; margin-bottom: 1rem;">
                <p style="margin: 0; color: #856404;">
                    <strong>ü§ñ Real AI Active:</strong> This mode connects to Google's Gemini AI. Responses are generated by actual AI, which may occasionally be unavailable or produce unexpected results.
                </p>
            </div>
            
            <div class="info-box">
                <p>
                    <strong>üåê What's happening:</strong> Just like our spinner wheel, AI has multiple layers. Each layer looks at what came before and decides what patterns it sees. Watch how "Cat" flows through and becomes different endings based on what each layer detects!
                </p>
            </div>
            
            <!-- Better explanation cards -->
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 1rem; margin: 2rem 0;">
                <div style="background: white; padding: 1.5rem; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
                    <h3 style="color: var(--primary); margin-bottom: 0.5rem;">üéØ Layer 1: Context</h3>
                    <p style="color: var(--text-muted); font-size: 0.9rem;">
                        "What type of text is this?" <br>
                        Detects if input is about animals, food, or places - just like choosing Cat vs Dog in Tab 1!
                    </p>
                </div>
                
                <div style="background: white; padding: 1.5rem; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
                    <h3 style="color: var(--primary); margin-bottom: 0.5rem;">üîÑ Layer 2: Action</h3>
                    <p style="color: var(--text-muted); font-size: 0.9rem;">
                        "What's happening?" <br>
                        Based on context, picks an action - sleeping, playing, or eating - just like the middle wheel!
                    </p>
                </div>
                
                <div style="background: white; padding: 1.5rem; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
                    <h3 style="color: var(--primary); margin-bottom: 0.5rem;">üìù Layer 3: Output</h3>
                    <p style="color: var(--text-muted); font-size: 0.9rem;">
                        "Complete the thought!" <br>
                        Generates the final word based on previous layers - sofa, window, kitchen, etc!
                    </p>
                </div>
            </div>
            
            <!-- Network visualization -->
            <div class="network-container">
                <div class="wheels-row" id="wheelsRow">
                    <div class="wheel-column">
                        <div class="wheel-label">Layer 1: Context</div>
                        <div class="mini-wheel" id="patternWheel"></div>
                        <div style="text-align: center; margin-top: 0.5rem; font-size: 0.85rem; color: var(--text-muted);">
                            Detecting: <span id="layer1Status" style="font-weight: 600;">Ready</span>
                        </div>
                    </div>
                    
                    <div class="wheel-column">
                        <div class="wheel-label">Layer 2: Action</div>
                        <div class="mini-wheel" id="conceptWheel"></div>
                        <div style="text-align: center; margin-top: 0.5rem; font-size: 0.85rem; color: var(--text-muted);">
                            Processing: <span id="layer2Status" style="font-weight: 600;">Waiting</span>
                        </div>
                    </div>
                    
                    <div class="wheel-column">
                        <div class="wheel-label">Layer 3: Output</div>
                        <div class="mini-wheel" id="wordWheel"></div>
                        <div style="text-align: center; margin-top: 0.5rem; font-size: 0.85rem; color: var(--text-muted);">
                            Generating: <span id="layer3Status" style="font-weight: 600;">Waiting</span>
                        </div>
                    </div>
                </div>
                
                <!-- Network output display -->
                <div class="network-output">
                    <div class="network-output-text" id="networkOutput">
                        Type "Cat", "Dog", or any word to see how layers process it!
                    </div>
                    <p id="networkExplanation" style="color: var(--text-muted); font-size: 0.9rem; margin-top: 0.5rem;">
                        Each layer transforms the input based on patterns it learned - exactly like our spinner wheels!
                    </p>
                </div>
            </div>
            
            <!-- Simplified controls -->
            <div class="network-controls">
                <input type="text" id="networkInput" 
                       placeholder="Try: Cat, Dog, Play, Sleep" 
                       style="padding: 0.75rem 1rem; border: 2px solid var(--primary); border-radius: 8px; font-size: 1rem; min-width: 200px;">
                
                <button class="network-btn" onclick="runNetwork()">
                    ‚ö° Process Through Layers
                </button>
                
                <button class="network-btn" onclick="autoDemo()" style="background: var(--success);">
                    üé¨ Auto Demo
                </button>
                
                <button class="network-btn" onclick="resetNetwork()" style="background: var(--text-muted);">
                    üîÑ Reset
                </button>
            </div>
            
            <!-- Pattern examples -->
            <div style="margin-top: 2rem; text-align: center;">
                <p style="color: var(--text-muted); margin-bottom: 0.5rem;">Quick examples to try:</p>
                <div style="display: flex; gap: 0.5rem; justify-content: center; flex-wrap: wrap;">
                    <button class="preset-pill" onclick="document.getElementById('networkInput').value='Cat'; runNetwork()" 
                            style="padding: 0.4rem 1rem; border-radius: 999px; background: white; border: 2px solid var(--primary); color: var(--primary); cursor: pointer;">
                        üê± Cat
                    </button>
                    <button class="preset-pill" onclick="document.getElementById('networkInput').value='Dog'; runNetwork()"
                            style="padding: 0.4rem 1rem; border-radius: 999px; background: white; border: 2px solid var(--primary); color: var(--primary); cursor: pointer;">
                        üê∂ Dog
                    </button>
                    <button class="preset-pill" onclick="document.getElementById('networkInput').value='Sleep'; runNetwork()"
                            style="padding: 0.4rem 1rem; border-radius: 999px; background: white; border: 2px solid var(--primary); color: var(--primary); cursor: pointer;">
                        üò¥ Sleep
                    </button>
                    <button class="preset-pill" onclick="document.getElementById('networkInput').value='Play'; runNetwork()"
                            style="padding: 0.4rem 1rem; border-radius: 999px; background: white; border: 2px solid var(--primary); color: var(--primary); cursor: pointer;">
                        üéæ Play
                    </button>
                    <button class="preset-pill" onclick="document.getElementById('networkInput').value='Kitchen'; runNetwork()"
                            style="padding: 0.4rem 1rem; border-radius: 999px; background: white; border: 2px solid var(--primary); color: var(--primary); cursor: pointer;">
                        üç≥ Kitchen
                    </button>
                </div>
            </div>
            
            <div class="info-box" style="margin-top: 2rem;">
                <p>
                    <strong>üí° Key insight:</strong> This is the same process as Tab 1's spinner wheel, but showing the hidden layers! 
                    In real AI, there are hundreds of layers with millions of connections, but the principle is the same: 
                    each layer detects patterns and passes information to the next.
                </p>
                <p style="margin-top: 0.5rem;">
                    <strong>Connection to ChatGPT/Claude:</strong> When you type a message, it flows through many layers like this. 
                    Early layers understand context, middle layers grasp concepts, and final layers generate the actual words!
                </p>
            </div>
        </div>
    </div>
    
    <script>
        // Simple word choices for demonstration
        const wordChoices = {
            start: [
                { word: 'Cat', emoji: 'üê±' },
                { word: 'Dog', emoji: 'üê∂' }
            ],
            catMiddle: [
                { word: 'sleeping', emoji: 'üò¥', prob: 0.5 },
                { word: 'hungry', emoji: 'üçΩÔ∏è', prob: 0.3 },
                { word: 'playful', emoji: 'üéæ', prob: 0.2 }
            ],
            dogMiddle: [
                { word: 'playful', emoji: 'üéæ', prob: 0.5 },
                { word: 'hungry', emoji: 'üçΩÔ∏è', prob: 0.3 },
                { word: 'sleeping', emoji: 'üò¥', prob: 0.2 }
            ],
            sleepingEnd: [
                { word: 'sofa', emoji: 'üõãÔ∏è', prob: 0.6 },
                { word: 'window', emoji: 'ü™ü', prob: 0.4 }
            ],
            hungryEnd: [
                { word: 'kitchen', emoji: 'üç≥', prob: 0.7 },
                { word: 'sofa', emoji: 'üõãÔ∏è', prob: 0.3 }
            ],
            playfulEnd: [
                { word: 'yard', emoji: 'üå≥', prob: 0.6 },
                { word: 'sofa', emoji: 'üõãÔ∏è', prob: 0.4 }
            ]
        };
        
        // Seeded random for consistent results
        function mulberry32(a) {
            return function() {
                let t = a += 0x6D2B79F5;
                t = Math.imul(t^t>>>15, t|1);
                t ^= t + Math.imul(t^t>>>7, t|61);
                return ((t^t>>>14)>>>0) / 4294967296;
            }
        }
        
        let rng = mulberry32(Date.now());
        let currentSequence = [];
        let patterns = {};
        let liveGenerationTimer = null;
        let currentTargetPattern = 'üê∂üò¥ü™ü';
        
        // Network tab data
        let networkMode = 'manual';
        let aiMode = 'simulation';
        let networkConnections = {
            forward1: 0.5,
            forward2: 0.5,
            backward: 0.3
        };
        
        const patternWheelData = {
            'question': { emoji: '‚ùì', prob: 0.33 },
            'statement': { emoji: 'üìù', prob: 0.33 },
            'command': { emoji: '‚ö°', prob: 0.34 }
        };
        
        const conceptWheelData = {
            question: {
                'what': { emoji: 'üîç', prob: 0.4 },
                'why': { emoji: 'üí≠', prob: 0.3 },
                'how': { emoji: '‚öôÔ∏è', prob: 0.3 }
            },
            statement: {
                'fact': { emoji: 'üìä', prob: 0.4 },
                'opinion': { emoji: 'üí¨', prob: 0.3 },
                'description': { emoji: 'üñºÔ∏è', prob: 0.3 }
            },
            command: {
                'action': { emoji: 'üéØ', prob: 0.4 },
                'object': { emoji: 'üì¶', prob: 0.3 },
                'modifier': { emoji: '‚ú®', prob: 0.3 }
            }
        };
        
        const wordWheelData = {
            what: ['fish', 'mice', 'food', 'water'],
            why: ['hungry', 'curious', 'playful'],
            how: ['quickly', 'slowly', 'carefully'],
            fact: ['cats', 'dogs', 'exist'],
            opinion: ['good', 'interesting', 'important'],
            description: ['furry', 'small', 'cute'],
            action: ['run', 'jump', 'play'],
            object: ['ball', 'toy', 'treat'],
            modifier: ['very', 'quite', 'extremely']
        };
        
        // Tab switching
        document.querySelectorAll('.tab-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                const tabId = btn.dataset.tab;
                
                document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                
                document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
                document.getElementById(tabId).classList.add('active');
                
                // Initialize tabs
                if (tabId === 'challenge') {
                    generateNewChallenge();
                } else if (tabId === 'network') {
                    initializeNetworkWheels();
                }
            });
        });
        
        // Apply temperature to probabilities
        function applyTemperature(probs, temperature) {
            if (temperature === 0) temperature = 0.01;
            
            const scaled = probs.map(p => Math.pow(p, 1/temperature));
            const sum = scaled.reduce((a, b) => a + b, 0);
            return scaled.map(s => s / sum);
        }
        
        // Apply top-p filtering
        function applyFavoritesFilter(choices, probs, pCut) {
            if (pCut >= 0.99) return { choices, probs };
            
            const indexed = probs.map((p, i) => ({prob: p, idx: i}))
                                 .sort((a, b) => b.prob - a.prob);
            
            let cumSum = 0;
            const keep = [];
            
            for (const item of indexed) {
                keep.push(item.idx);
                cumSum += item.prob;
                if (cumSum >= pCut) break;
            }
            
            const keptChoices = keep.map(i => choices[i]);
            const keptProbs = keep.map(i => probs[i]);
            const sum = keptProbs.reduce((a, b) => a + b, 0);
            
            return { 
                choices: keptChoices, 
                probs: keptProbs.map(p => p / sum) 
            };
        }
        
        // Apply repetition penalty
        function applyNoRepeatNudge(choices, probs, historyEmojis, strength = 0.2) {
            const adjustedProbs = probs.slice();
            choices.forEach((choice, i) => {
                if (historyEmojis.includes(choice.emoji)) {
                    adjustedProbs[i] *= (1 - strength);
                }
            });
            const sum = adjustedProbs.reduce((a, b) => a + b, 0);
            return adjustedProbs.map(p => p / sum);
        }
        
        // Create wheel sections
        function createWheel(choices, probabilities, wheelId = 'spinnerWheel') {
            const wheel = document.getElementById(wheelId);
            if (!wheel) return;
            
            wheel.innerHTML = '';
            wheel.style.background = '';
            
            if (!choices || choices.length === 0) return;
            
            let currentAngle = 0;
            const sections = [];
            
            choices.forEach((choice, i) => {
                const prob = probabilities[i];
                const angle = prob * 360;
                const endAngle = currentAngle + angle;
                
                let color;
                if (prob > 0.4) {
                    color = '#10b981';
                } else if (prob > 0.2) {
                    color = '#f59e0b';
                } else {
                    color = '#8b5cf6';
                }
                
                sections.push({
                    start: currentAngle,
                    end: endAngle,
                    color: color,
                    label: choice.emoji
                });
                
                currentAngle = endAngle;
            });
            
            const gradientParts = [];
            sections.forEach(section => {
                const startPercent = (section.start / 360) * 100;
                const endPercent = (section.end / 360) * 100;
                gradientParts.push(`${section.color} ${startPercent}% ${endPercent}%`);
            });
            
            wheel.style.background = `conic-gradient(${gradientParts.join(', ')})`;
            
            sections.forEach((section, i) => {
                const midAngle = (section.start + section.end) / 2;
                const labelRadius = 80;
                const x = Math.cos((midAngle - 90) * Math.PI / 180) * labelRadius + 140;
                const y = Math.sin((midAngle - 90) * Math.PI / 180) * labelRadius + 140;
                
                const label = document.createElement('div');
                label.className = 'spinner-label';
                label.textContent = section.label;
                label.style.left = x + 'px';
                label.style.top = y + 'px';
                label.style.transform = 'translate(-50%, -50%)';
                wheel.appendChild(label);
            });
            
            return sections;
        }
        
        // Spin animation
        async function spinWheel(position) {
            const wheel = document.getElementById('spinnerWheel');
            const titles = ['Choosing the Start...', 'Choosing the Middle...', 'Choosing the End!'];
            document.getElementById('stageTitle').textContent = titles[position];
            
            const contextFill = document.getElementById('contextFill');
            contextFill.style.width = ((position + 1) / 3 * 100) + '%';
            
            const quickMode = document.getElementById('quickMode').checked;
            
            let choices, probs;
            const historyEmojis = currentSequence.map(w => {
                const all = [...wordChoices.start, ...wordChoices.catMiddle, ...wordChoices.dogMiddle,
                           ...wordChoices.sleepingEnd, ...wordChoices.hungryEnd, ...wordChoices.playfulEnd];
                const found = all.find(c => c.word === w);
                return found ? found.emoji : '';
            });
            
            if (position === 0) {
                choices = wordChoices.start;
                probs = [0.5, 0.5];
            } else if (position === 1) {
                const firstWord = currentSequence[0];
                choices = firstWord === 'Cat' ? wordChoices.catMiddle : wordChoices.dogMiddle;
                probs = choices.map(c => c.prob);
                
                const avoidStrength = parseFloat(document.getElementById('avoidRepeats').value);
                probs = applyNoRepeatNudge(choices, probs, historyEmojis, avoidStrength);
            } else {
                const middleWord = currentSequence[1];
                const endKey = middleWord + 'End';
                choices = wordChoices[endKey];
                probs = choices.map(c => c.prob);
                
                const avoidStrength = parseFloat(document.getElementById('avoidRepeats').value);
                probs = applyNoRepeatNudge(choices, probs, historyEmojis, avoidStrength);
            }
            
            const creativity = parseFloat(document.getElementById('creativity').value);
            probs = applyTemperature(probs, creativity);
            
            const pCut = parseFloat(document.getElementById('favorites').value);
            const filtered = applyFavoritesFilter(choices, probs, pCut);
            choices = filtered.choices;
            probs = filtered.probs;
            
            const sections = createWheel(choices, probs);
            
            if (quickMode) {
                wheel.classList.add('fast');
            }
            
            wheel.classList.add('spinning');
            
            const spinDuration = quickMode ? 800 : 3000;
            await new Promise(resolve => setTimeout(resolve, spinDuration));
            
            const random = rng();
            let cumProb = 0;
            let selected = choices[0];
            
            for (let i = 0; i < probs.length; i++) {
                cumProb += probs[i];
                if (random <= cumProb) {
                    selected = choices[i];
                    break;
                }
            }
            
            currentSequence.push(selected.word);
            
            const selectedSection = sections.find(s => s.label === selected.emoji);
            if (selectedSection) {
                const stopAngle = (selectedSection.start + selectedSection.end) / 2;
                wheel.style.transform = `rotate(${1800 - stopAngle}deg)`;
            }
            wheel.classList.remove('spinning', 'fast');
            
            const strip = document.getElementById('comicStrip');
            const bubble = document.createElement('div');
            bubble.className = 'comic-bubble';
            bubble.textContent = selected.emoji;
            strip.appendChild(bubble);
            
            if (probs[choices.indexOf(selected)] < 0.15) {
                createSparkle();
            }
        }
        
        // Start spinning
        async function startSpinning() {
            currentSequence = [];
            document.getElementById('spinnerStage').classList.add('active');
            document.getElementById('comicStrip').innerHTML = '';
            document.getElementById('contextFill').style.width = '0%';
            
            rng = mulberry32(Date.now());
            
            for (let i = 0; i < 3; i++) {
                await spinWheel(i);
                await new Promise(resolve => setTimeout(resolve, 500));
            }
        }
        
        // Create sparkle effect
        function createSparkle() {
            const sparkle = document.createElement('div');
            sparkle.className = 'sparkle';
            sparkle.textContent = '‚ú®';
            sparkle.style.left = Math.random() * window.innerWidth + 'px';
            sparkle.style.top = Math.random() * window.innerHeight + 'px';
            document.body.appendChild(sparkle);
            
            setTimeout(() => sparkle.remove(), 1000);
        }
        
        // Create confetti
        function createConfetti() {
            for (let i = 0; i < 30; i++) {
                setTimeout(() => {
                    const confetti = document.createElement('div');
                    confetti.className = 'confetti';
                    confetti.style.left = Math.random() * window.innerWidth + 'px';
                    confetti.style.backgroundColor = 
                        ['#0f766e', '#10b981', '#f59e0b'][Math.floor(Math.random() * 3)];
                    document.body.appendChild(confetti);
                    
                    setTimeout(() => confetti.remove(), 3000);
                }, i * 50);
            }
        }
        
        // Generate many patterns
        async function generateMany() {
            const gallery = document.getElementById('patternGallery');
            gallery.innerHTML = '';
            patterns = {};
            
            const count = parseInt(document.getElementById('patternCount').value);
            const useSamePatterns = document.getElementById('samePatterns').checked;
            
            const spinnerStage = document.getElementById('patternSpinner');
            spinnerStage.style.display = 'block';
            
            const wheel = document.getElementById('patternWheel');
            const creativity = parseFloat(document.getElementById('creativity').value);
            const pCut = parseFloat(document.getElementById('favorites').value);
            
            // Show animation stages
            document.querySelector('#patternSpinner .stage-title').textContent = 'Stage 1: Start';
            let choices = wordChoices.start;
            let probs = [0.5, 0.5];
            probs = applyTemperature(probs, creativity);
            const filtered1 = applyFavoritesFilter(choices, probs, pCut);
            createWheel(filtered1.choices, filtered1.probs, 'patternWheel');
            
            wheel.classList.add('spinning', 'fast');
            await new Promise(resolve => setTimeout(resolve, 800));
            wheel.classList.remove('spinning', 'fast');
            await new Promise(resolve => setTimeout(resolve, 300));
            
            document.querySelector('#patternSpinner .stage-title').textContent = 'Stage 2: Middle';
            choices = wordChoices.catMiddle;
            probs = choices.map(c => c.prob);
            probs = applyTemperature(probs, creativity);
            const filtered2 = applyFavoritesFilter(choices, probs, pCut);
            createWheel(filtered2.choices, filtered2.probs, 'patternWheel');
            
            wheel.classList.add('spinning', 'fast');
            await new Promise(resolve => setTimeout(resolve, 800));
            wheel.classList.remove('spinning', 'fast');
            await new Promise(resolve => setTimeout(resolve, 300));
            
            document.querySelector('#patternSpinner .stage-title').textContent = 'Stage 3: End';
            choices = wordChoices.sleepingEnd;
            probs = choices.map(c => c.prob);
            probs = applyTemperature(probs, creativity);
            const filtered3 = applyFavoritesFilter(choices, probs, pCut);
            createWheel(filtered3.choices, filtered3.probs, 'patternWheel');
            
            wheel.classList.add('spinning', 'fast');
            await new Promise(resolve => setTimeout(resolve, 800));
            wheel.classList.remove('spinning', 'fast');
            
            document.querySelector('#patternSpinner .stage-title').textContent = 'Generating patterns...';
            
            if (useSamePatterns) {
                rng = mulberry32(12345);
            } else {
                rng = mulberry32(Math.floor(Math.random() * 1000000));
            }
            
            // Generate patterns
            for (let i = 0; i < count; i++) {
                const sequence = [];
                const historyEmojis = [];
                
                const catBias = 0.5;
                let firstWord;
                if (rng() < catBias) {
                    firstWord = wordChoices.start[0];
                } else {
                    firstWord = wordChoices.start[1];
                }
                sequence.push(firstWord.emoji);
                historyEmojis.push(firstWord.emoji);
                
                const middleChoices = firstWord.word === 'Cat' ? wordChoices.catMiddle : wordChoices.dogMiddle;
                let middleProbs = middleChoices.map(c => c.prob);
                
                middleProbs = applyTemperature(middleProbs, creativity);
                
                const filteredMiddle = applyFavoritesFilter(middleChoices, middleProbs, pCut);
                
                let cumProb = 0;
                const middleRandom = rng();
                let middleWord = filteredMiddle.choices[0];
                
                for (let j = 0; j < filteredMiddle.probs.length; j++) {
                    cumProb += filteredMiddle.probs[j];
                    if (middleRandom <= cumProb) {
                        middleWord = filteredMiddle.choices[j];
                        break;
                    }
                }
                sequence.push(middleWord.emoji);
                historyEmojis.push(middleWord.emoji);
                
                const endKey = middleWord.word + 'End';
                const endChoices = wordChoices[endKey];
                if (!endChoices) continue;
                
                let endProbs = endChoices.map(c => c.prob);
                
                const avoidStrength = parseFloat(document.getElementById('avoidRepeats').value);
                endProbs = applyNoRepeatNudge(endChoices, endProbs, historyEmojis, avoidStrength);
                
                endProbs = applyTemperature(endProbs, creativity);
                
                const filteredEnd = applyFavoritesFilter(endChoices, endProbs, pCut);
                
                cumProb = 0;
                const endRandom = rng();
                let endWord = filteredEnd.choices[0];
                
                for (let j = 0; j < filteredEnd.probs.length; j++) {
                    cumProb += filteredEnd.probs[j];
                    if (endRandom <= cumProb) {
                        endWord = filteredEnd.choices[j];
                        break;
                    }
                }
                sequence.push(endWord.emoji);
                
                const patternKey = sequence.join('');
                patterns[patternKey] = (patterns[patternKey] || 0) + 1;
            }
            
            document.querySelector('#patternSpinner .stage-title').textContent = 'Your settings affect all stages!';
            
            const patternArray = Object.entries(patterns);
            patternArray.sort((a, b) => b[1] - a[1]);
            
            const uniqueCount = patternArray.length;
            const duplicateCount = patternArray.filter(([_, c]) => c > 1).length;
            const seedInfo = useSamePatterns ? ' (using fixed seed - same every time)' : ' (using random seed - different every time)';
            document.getElementById('patternLegend').textContent = 
                `Generated ${count} patterns${seedInfo}: ${duplicateCount} duplicates (big tiles), ${uniqueCount - duplicateCount} unique (small tiles)`;
            
            patternArray.forEach(([pattern, count], index) => {
                const chip = document.createElement('div');
                chip.className = 'pattern-chip';
                
                if (index === 0 && count > 2) {
                    chip.classList.add('common');
                } else if (count === 1) {
                    chip.classList.add('rare');
                }
                
                chip.textContent = pattern;
                
                const countLabel = document.createElement('div');
                countLabel.className = 'pattern-count';
                countLabel.textContent = count;
                chip.appendChild(countLabel);
                
                gallery.appendChild(chip);
            });
        }
        
        // Generate new challenge
        function generateNewChallenge() {
            const starts = ['üê±', 'üê∂'];
            const start = starts[Math.floor(Math.random() * 2)];
            
            let middles;
            if (start === 'üê±') {
                middles = ['üò¥', 'üçΩÔ∏è', 'üéæ'];
            } else {
                middles = ['üéæ', 'üçΩÔ∏è', 'üò¥'];
            }
            const middle = middles[Math.floor(Math.random() * 3)];
            
            let ends;
            if (middle === 'üò¥') {
                ends = ['üõãÔ∏è', 'ü™ü'];
            } else if (middle === 'üçΩÔ∏è') {
                ends = ['üç≥', 'üõãÔ∏è'];
            } else {
                ends = ['üå≥', 'üõãÔ∏è'];
            }
            const end = ends[Math.floor(Math.random() * 2)];
            
            currentTargetPattern = start + middle + end;
            
            const targetSequence = document.getElementById('targetSequence');
            targetSequence.innerHTML = `
                <div class="target-piece">${start}</div>
                <div class="target-arrow">‚Üí</div>
                <div class="target-piece">${middle}</div>
                <div class="target-arrow">‚Üí</div>
                <div class="target-piece">${end}</div>
            `;
            
            document.getElementById('startBias').value = 50;
            document.getElementById('challengeCreativity').value = 1.0;
            document.getElementById('challengeFavorites').value = 0.8;
            
            updateLiveGeneration();
        }
        
        // Generate challenge sequence
        function generateChallengeSequence() {
            const sequence = [];
            const historyEmojis = [];
            
            const catBias = parseFloat(document.getElementById('startBias').value) / 100;
            const creativity = parseFloat(document.getElementById('challengeCreativity').value);
            const pCut = parseFloat(document.getElementById('challengeFavorites').value);
            
            const firstWord = rng() < catBias ? wordChoices.start[0] : wordChoices.start[1];
            sequence.push(firstWord.emoji);
            historyEmojis.push(firstWord.emoji);
            
            const middleChoices = firstWord.word === 'Cat' ? wordChoices.catMiddle : wordChoices.dogMiddle;
            let middleProbs = applyTemperature(middleChoices.map(c => c.prob), creativity);
            
            const filteredMiddle = applyFavoritesFilter(middleChoices, middleProbs, pCut);
            
            let cumProb = 0;
            const middleRandom = rng();
            for (let i = 0; i < filteredMiddle.probs.length; i++) {
                cumProb += filteredMiddle.probs[i];
                if (middleRandom <= cumProb) {
                    sequence.push(filteredMiddle.choices[i].emoji);
                    historyEmojis.push(filteredMiddle.choices[i].emoji);
                    
                    const endKey = filteredMiddle.choices[i].word + 'End';
                    const endChoices = wordChoices[endKey];
                    let endProbs = applyTemperature(endChoices.map(c => c.prob), creativity);
                    
                    const filteredEnd = applyFavoritesFilter(endChoices, endProbs, pCut);
                    
                    cumProb = 0;
                    const endRandom = rng();
                    for (let j = 0; j < filteredEnd.probs.length; j++) {
                        cumProb += filteredEnd.probs[j];
                        if (endRandom <= cumProb) {
                            sequence.push(filteredEnd.choices[j].emoji);
                            break;
                        }
                    }
                    break;
                }
            }
            
            return sequence.join('');
        }
        
        // Update live generation
        function updateLiveGeneration() {
            clearTimeout(liveGenerationTimer);
            
            liveGenerationTimer = setTimeout(() => {
                const container = document.getElementById('livePatterns');
                container.innerHTML = '';
                
                const baseSeed = Date.now();
                
                for (let i = 0; i < 5; i++) {
                    rng = mulberry32(baseSeed + i * 1000);
                    const sequence = generateChallengeSequence();
                    
                    const pattern = document.createElement('div');
                    pattern.className = 'live-pattern';
                    pattern.textContent = sequence;
                    pattern.style.animationDelay = `${i * 0.1}s`;
                    container.appendChild(pattern);
                }
                
                updateSuccessRate();
            }, 100);
        }
        
        // Update success rate
        function updateSuccessRate() {
            let hits = 0;
            const attempts = 100;
            
            const baseSeed = Date.now();
            
            for (let i = 0; i < attempts; i++) {
                rng = mulberry32(baseSeed + i);
                const sequence = generateChallengeSequence();
                if (sequence === currentTargetPattern) {
                    hits++;
                }
            }
            
            const successRate = (hits / attempts * 100).toFixed(1);
            document.getElementById('successRate').textContent = successRate + '%';
            document.getElementById('successChance').textContent = successRate + '%';
            
            const tipText = document.getElementById('tipText');
            const rate = parseFloat(successRate);
            
            if (rate < 5) {
                tipText.textContent = "üí° Hey! I'd slide that bias ALL the way to the right animal and turn creativity way down!";
            } else if (rate < 15) {
                tipText.textContent = "üéØ Getting warmer! Keep that creativity low for consistent results.";
            } else if (rate < 30) {
                tipText.textContent = "‚ú® Nice progress! You're figuring out the pattern.";
            } else {
                tipText.textContent = "üèÜ Wow, you've mastered it! That's a great setup!";
            }
        }
        
        // Network functions
        function initializeNetworkWheels() {
            if (!document.getElementById('patternWheel')) return;
            
            createNetworkWheel('patternWheel', Object.values(patternWheelData));
            createNetworkWheel('conceptWheel', Object.values(conceptWheelData.question));
            createNetworkWheel('wordWheel', ['Ready', 'to', 'generate']);
            
            addConnectionLines();
        }
        
        function createNetworkWheel(wheelId, data) {
            const wheel = document.getElementById(wheelId);
            if (!wheel) return;
            
            wheel.innerHTML = '';
            wheel.style.background = '';
            
            let currentAngle = 0;
            const sections = [];
            
            const items = typeof data[0] === 'string' ? 
                data.map(d => ({text: d, prob: 1/data.length})) : 
                data;
            
            items.forEach((item, i) => {
                const prob = item.prob || 1/items.length;
                const angle = prob * 360;
                const endAngle = currentAngle + angle;
                
                let color;
                if (prob > 0.4) {
                    color = '#10b981';
                } else if (prob > 0.2) {
                    color = '#f59e0b';
                } else {
                    color = '#8b5cf6';
                }
                
                sections.push({
                    start: currentAngle,
                    end: endAngle,
                    color: color
                });
                
                currentAngle = endAngle;
            });
            
            const gradientParts = [];
            sections.forEach(section => {
                const startPercent = (section.start / 360) * 100;
                const endPercent = (section.end / 360) * 100;
                gradientParts.push(`${section.color} ${startPercent}% ${endPercent}%`);
            });
            
            wheel.style.background = `conic-gradient(${gradientParts.join(', ')})`;
            
            const centerLabel = document.createElement('div');
            centerLabel.style.position = 'absolute';
            centerLabel.style.top = '50%';
            centerLabel.style.left = '50%';
            centerLabel.style.transform = 'translate(-50%, -50%)';
            centerLabel.style.color = 'white';
            centerLabel.style.fontWeight = 'bold';
            centerLabel.style.fontSize = '2rem';
            centerLabel.style.textShadow = '0 2px 4px rgba(0,0,0,0.3)';
            
            if (items[0].emoji) {
                centerLabel.textContent = items[0].emoji;
            } else {
                centerLabel.textContent = items[0].text ? items[0].text.substring(0, 3) : '?';
            }
            
            wheel.appendChild(centerLabel);
        }
        
        function addConnectionLines() {
            const wheelsRow = document.getElementById('wheelsRow');
            if (!wheelsRow) return;
            
            document.querySelectorAll('.connection-line').forEach(line => line.remove());
            
            const line1 = document.createElement('div');
            line1.className = 'connection-line';
            line1.style.position = 'absolute';
            line1.style.left = '25%';
            line1.style.top = '50%';
            line1.style.width = '20%';
            wheelsRow.appendChild(line1);
            
            const line2 = document.createElement('div');
            line2.className = 'connection-line';
            line2.style.position = 'absolute';
            line2.style.left = '55%';
            line2.style.top = '50%';
            line2.style.width = '20%';
            wheelsRow.appendChild(line2);
            
            const backLine = document.createElement('div');
            backLine.className = 'connection-line backward';
            backLine.style.position = 'absolute';
            backLine.style.left = '25%';
            backLine.style.bottom = '30%';
            backLine.style.width = '50%';
            backLine.style.opacity = '0.2';
            wheelsRow.appendChild(backLine);
        }
        
        // Set AI Mode
        function setAIMode(mode) {
            aiMode = mode;
            const modeDescription = document.getElementById('modeDescription');
            const aiDisclosure = document.getElementById('aiDisclosure');
            
            if (mode === 'simulation') {
                modeDescription.textContent = 'Currently using simplified simulation to demonstrate the concept';
                aiDisclosure.style.display = 'none';
            } else {
                modeDescription.textContent = 'Using Google Gemini to generate real AI responses';
                aiDisclosure.style.display = 'block';
            }
        }
        
        // Call Gemini API
        async function callGeminiAPI(prompt) {
            try {
                const response = await fetch('/api/gemini', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        contents: [{
                            role: 'user',
                            parts: [{
                                text: prompt
                            }]
                        }]
                    })
                });
                
                if (!response.ok) {
                    throw new Error(`API error: ${response.status}`);
                }
                
                const data = await response.json();
                const text = data.candidates?.[0]?.content?.parts?.[0]?.text || 'No response';
                return text;
                
            } catch (error) {
                console.error('Gemini API error:', error);
                throw error;
            }
        }
        
        async function runNetwork() {
            const input = document.getElementById('networkInput').value || 'cat';
            const output = document.getElementById('networkOutput');
            const explanation = document.getElementById('networkExplanation');
            
            // Update layer status
            document.getElementById('layer1Status').textContent = 'Processing...';
            document.getElementById('layer2Status').textContent = 'Waiting';
            document.getElementById('layer3Status').textContent = 'Waiting';
            
            if (aiMode === 'real') {
                try {
                    // Layer 1: Context Detection
                    animateConnection(0);
                    const layer1Prompt = `You are simulating a neural network layer. Given the input "${input}", classify it as one of: question, statement, or command. Respond with ONLY the single word classification, nothing else.`;
                    
                    let patternType = 'statement';
                    try {
                        const layer1Response = await callGeminiAPI(layer1Prompt);
                        patternType = layer1Response.toLowerCase().trim();
                        if (!['question', 'statement', 'command'].includes(patternType)) {
                            patternType = 'statement';
                        }
                    } catch (error) {
                        // Fallback to simulation logic
                        if (input.includes('?') || input.includes('what') || input.includes('why')) {
                            patternType = 'question';
                        } else if (input.includes('!') || input.includes('do') || input.includes('make')) {
                            patternType = 'command';
                        }
                    }
                    
                    // Update wheel 1
                    const patternProbs = Object.keys(patternWheelData).map(key => {
                        return {
                            emoji: patternWheelData[key].emoji,
                            prob: key === patternType ? 0.7 : 0.15
                        };
                    });
                    createNetworkWheel('patternWheel', patternProbs);
                    document.getElementById('layer1Status').textContent = patternType;
                    
                    await new Promise(resolve => setTimeout(resolve, 500));
                    
                    // Layer 2: Action Processing
                    animateConnection(1);
                    document.getElementById('layer2Status').textContent = 'Processing...';
                    
                    const layer2Prompt = `You are simulating a neural network layer. The input "${input}" was classified as a ${patternType}. Now classify the action as one of: ${patternType === 'question' ? 'what, why, how' : patternType === 'statement' ? 'fact, opinion, description' : 'action, object, modifier'}. Respond with ONLY the single word, nothing else.`;
                    
                    let selectedConcept = 'fact';
                    try {
                        const layer2Response = await callGeminiAPI(layer2Prompt);
                        selectedConcept = layer2Response.toLowerCase().trim();
                    } catch (error) {
                        // Fallback
                        const conceptData = conceptWheelData[patternType];
                        const concepts = Object.keys(conceptData);
                        selectedConcept = concepts[Math.floor(Math.random() * concepts.length)];
                    }
                    
                    // Update wheel 2
                    const conceptData = conceptWheelData[patternType];
                    createNetworkWheel('conceptWheel', Object.values(conceptData));
                    document.getElementById('layer2Status').textContent = selectedConcept;
                    
                    await new Promise(resolve => setTimeout(resolve, 500));
                    
                    // Layer 3: Output Generation
                    animateConnection(2);
                    document.getElementById('layer3Status').textContent = 'Generating...';
                    
                    const layer3Prompt = `Complete this sentence naturally with exactly ONE word: "${input}" ‚Üí The next logical word is:`;
                    
                    let finalWord = 'output';
                    try {
                        const layer3Response = await callGeminiAPI(layer3Prompt);
                        // Extract first word from response
                        finalWord = layer3Response.trim().split(/\s+/)[0].replace(/[^\w]/g, '').toLowerCase();
                        if (!finalWord) finalWord = 'generated';
                    } catch (error) {
                        // Fallback
                        const words = wordWheelData[selectedConcept] || ['output'];
                        finalWord = words[Math.floor(Math.random() * words.length)];
                    }
                    
                    // Update wheel 3
                    createNetworkWheel('wordWheel', [finalWord]);
                    document.getElementById('layer3Status').textContent = finalWord;
                    
                    output.textContent = `Input: "${input}" ‚Üí AI Output: "${finalWord}"`;
                    explanation.textContent = `Real AI processed: ${patternType} ‚Üí ${selectedConcept} ‚Üí ${finalWord}`;
                    
                } catch (error) {
                    output.textContent = 'AI temporarily unavailable - falling back to simulation';
                    explanation.textContent = 'The AI service is not responding. Try the simulation mode!';
                    
                    // Reset status
                    document.getElementById('layer1Status').textContent = 'Error';
                    document.getElementById('layer2Status').textContent = 'Error';
                    document.getElementById('layer3Status').textContent = 'Error';
                }
                
            } else {
                // Original simulation code
                rng = mulberry32(Date.now());
                
                animateConnection(0);
                document.getElementById('layer1Status').textContent = 'Processing...';
                
                let patternType = 'statement';
                if (input.includes('?') || input.includes('what') || input.includes('why')) {
                    patternType = 'question';
                } else if (input.includes('!') || input.includes('do') || input.includes('make')) {
                    patternType = 'command';
                }
                
                const patternProbs = Object.keys(patternWheelData).map(key => {
                    return {
                        emoji: patternWheelData[key].emoji,
                        prob: key === patternType ? 0.7 : 0.15
                    };
                });
                createNetworkWheel('patternWheel', patternProbs);
                document.getElementById('layer1Status').textContent = patternType;
                
                await new Promise(resolve => setTimeout(resolve, 500));
                
                animateConnection(1);
                document.getElementById('layer2Status').textContent = 'Processing...';
                
                const conceptData = conceptWheelData[patternType];
                createNetworkWheel('conceptWheel', Object.values(conceptData));
                
                await new Promise(resolve => setTimeout(resolve, 500));
                
                const concepts = Object.keys(conceptData);
                const conceptProbs = concepts.map(c => conceptData[c].prob);
                const selectedConcept = concepts[Math.floor(rng() * concepts.length)];
                document.getElementById('layer2Status').textContent = selectedConcept;
                
                animateConnection(2);
                document.getElementById('layer3Status').textContent = 'Generating...';
                
                const words = wordWheelData[selectedConcept] || ['output'];
                createNetworkWheel('wordWheel', words);
                
                await new Promise(resolve => setTimeout(resolve, 500));
                
                const finalWord = words[Math.floor(rng() * words.length)];
                document.getElementById('layer3Status').textContent = finalWord;
                
                output.textContent = `Input: "${input}" ‚Üí Output: "${finalWord}"`;
                explanation.textContent = `Pattern: ${patternType} ‚Üí Concept: ${selectedConcept} ‚Üí Word: ${finalWord}`;
                
                if (networkMode === 'train' || parseFloat(document.getElementById('backwardFlow')?.value || 30) > 0) {
                    await new Promise(resolve => setTimeout(resolve, 300));
                    animateBackwardFlow();
                }
            }
        }
        
        async function autoDemo() {
            const examples = ['Cat', 'Why', 'Play', 'Dog', 'Sleep'];
            for (const example of examples) {
                document.getElementById('networkInput').value = example;
                await runNetwork();
                await new Promise(resolve => setTimeout(resolve, 2000));
            }
        }
        
        function animateConnection(index) {
            const lines = document.querySelectorAll('.connection-line:not(.backward)');
            lines.forEach((line, i) => {
                if (i === index) {
                    line.classList.add('active');
                } else {
                    line.classList.remove('active');
                }
            });
        }
        
        function animateBackwardFlow() {
            const backLine = document.querySelector('.connection-line.backward');
            if (backLine) {
                backLine.classList.add('active');
                setTimeout(() => {
                    backLine.classList.remove('active');
                }, 1000);
            }
        }
        
        function resetNetwork() {
            createNetworkWheel('patternWheel', Object.values(patternWheelData));
            createNetworkWheel('conceptWheel', Object.values(conceptWheelData.question));
            createNetworkWheel('wordWheel', ['Ready', 'to', 'generate']);
            
            document.getElementById('networkOutput').textContent = 'Type "Cat", "Dog", or any word to see how layers process it!';
            document.getElementById('networkExplanation').textContent = 'Each layer transforms the input based on patterns it learned - exactly like our spinner wheels!';
            document.getElementById('networkInput').value = '';
            
            // Reset layer statuses
            document.getElementById('layer1Status').textContent = 'Ready';
            document.getElementById('layer2Status').textContent = 'Waiting';
            document.getElementById('layer3Status').textContent = 'Waiting';
            
            document.querySelectorAll('.connection-line').forEach(line => {
                line.classList.remove('active');
            });
        }
        
        function updateConnections() {
            const forward1 = parseFloat(document.getElementById('connection1').value) / 100;
            const forward2 = parseFloat(document.getElementById('connection2').value) / 100;
            const backward = parseFloat(document.getElementById('backwardFlow').value) / 100;
            
            const lines = document.querySelectorAll('.connection-line');
            if (lines[0]) lines[0].style.height = (3 + forward1 * 7) + 'px';
            if (lines[1]) lines[1].style.height = (3 + forward2 * 7) + 'px';
            if (lines[2]) lines[2].style.opacity = backward;
            
            networkConnections = { forward1, forward2, backward };
        }
        
        // Initialize on load
        window.addEventListener('load', () => {
            document.querySelectorAll('.big-btn').forEach(btn => {
                btn.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter' || e.key === ' ') {
                        e.preventDefault();
                        btn.click();
                    }
                });
            });
        });
    </script>
</body>
</html>
